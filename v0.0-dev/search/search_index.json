{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Client Common Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Common code and utilities for Frequenz API clients</p> <p>TODO(cookiecutter): Improve the README file</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Client Common Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>common<ul> <li>microgrid<ul> <li>components</li> </ul> </li> <li>pagination</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/common/","title":"Index","text":""},{"location":"reference/frequenz/client/common/#frequenz.client.common","title":"frequenz.client.common","text":"<p>Common code and utilities for Frequenz API clients.</p>"},{"location":"reference/frequenz/client/common/microgrid/","title":"Index","text":""},{"location":"reference/frequenz/client/common/microgrid/#frequenz.client.common.microgrid","title":"frequenz.client.common.microgrid","text":"<p>Frequenz microgrid definition.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/","title":"components","text":""},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components","title":"frequenz.client.common.microgrid.components","text":"<p>Defines the components that can be used in a microgrid.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory","title":"frequenz.client.common.microgrid.components.ComponentCategory","text":"<p>             Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>frequenz/client/common/microgrid/components/__init__.py</code> <pre><code>class ComponentCategory(Enum):\n    \"\"\"Possible types of microgrid component.\"\"\"\n\n    UNSPECIFIED = PBComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n    \"\"\"An unknown component category.\n\n    Useful for error handling, and marking unknown components in\n    a list of components with otherwise known categories.\n    \"\"\"\n\n    GRID = PBComponentCategory.COMPONENT_CATEGORY_GRID\n    \"\"\"The point where the local microgrid is connected to the grid.\"\"\"\n\n    METER = PBComponentCategory.COMPONENT_CATEGORY_METER\n    \"\"\"A meter, for measuring electrical metrics, e.g., current, voltage, etc.\"\"\"\n\n    INVERTER = PBComponentCategory.COMPONENT_CATEGORY_INVERTER\n    \"\"\"An electricity generator, with batteries or solar energy.\"\"\"\n\n    BATTERY = PBComponentCategory.COMPONENT_CATEGORY_BATTERY\n    \"\"\"A storage system for electrical energy, used by inverters.\"\"\"\n\n    EV_CHARGER = PBComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n    \"\"\"A station for charging electrical vehicles.\"\"\"\n\n    CHP = PBComponentCategory.COMPONENT_CATEGORY_CHP\n    \"\"\"A heat and power combustion plant (CHP stands for combined heat and power).\"\"\"\n\n    @classmethod\n    def from_proto(\n        cls, component_category: PBComponentCategory.ValueType\n    ) -&gt; ComponentCategory:\n        \"\"\"Convert a protobuf ComponentCategory message to ComponentCategory enum.\n\n        Args:\n            component_category: protobuf enum to convert\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == component_category for t in ComponentCategory):\n            return ComponentCategory.UNSPECIFIED\n        return cls(component_category)\n\n    def to_proto(self) -&gt; PBComponentCategory.ValueType:\n        \"\"\"Convert a ComponentCategory enum to protobuf ComponentCategory message.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = COMPONENT_CATEGORY_BATTERY\n</code></pre> <p>A storage system for electrical energy, used by inverters.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.CHP","title":"CHP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHP = COMPONENT_CATEGORY_CHP\n</code></pre> <p>A heat and power combustion plant (CHP stands for combined heat and power).</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.EV_CHARGER","title":"EV_CHARGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_CHARGER = COMPONENT_CATEGORY_EV_CHARGER\n</code></pre> <p>A station for charging electrical vehicles.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRID = COMPONENT_CATEGORY_GRID\n</code></pre> <p>The point where the local microgrid is connected to the grid.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.INVERTER","title":"INVERTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVERTER = COMPONENT_CATEGORY_INVERTER\n</code></pre> <p>An electricity generator, with batteries or solar energy.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.METER","title":"METER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METER = COMPONENT_CATEGORY_METER\n</code></pre> <p>A meter, for measuring electrical metrics, e.g., current, voltage, etc.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_CATEGORY_UNSPECIFIED\n</code></pre> <p>An unknown component category.</p> <p>Useful for error handling, and marking unknown components in a list of components with otherwise known categories.</p>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(\n    component_category: ValueType,\n) -&gt; ComponentCategory\n</code></pre> <p>Convert a protobuf ComponentCategory message to ComponentCategory enum.</p> PARAMETER  DESCRIPTION <code>component_category</code> <p>protobuf enum to convert</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>ComponentCategory</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/common/microgrid/components/__init__.py</code> <pre><code>@classmethod\ndef from_proto(\n    cls, component_category: PBComponentCategory.ValueType\n) -&gt; ComponentCategory:\n    \"\"\"Convert a protobuf ComponentCategory message to ComponentCategory enum.\n\n    Args:\n        component_category: protobuf enum to convert\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == component_category for t in ComponentCategory):\n        return ComponentCategory.UNSPECIFIED\n    return cls(component_category)\n</code></pre>"},{"location":"reference/frequenz/client/common/microgrid/components/#frequenz.client.common.microgrid.components.ComponentCategory.to_proto","title":"to_proto","text":"<pre><code>to_proto() -&gt; ValueType\n</code></pre> <p>Convert a ComponentCategory enum to protobuf ComponentCategory message.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/common/microgrid/components/__init__.py</code> <pre><code>def to_proto(self) -&gt; PBComponentCategory.ValueType:\n    \"\"\"Convert a ComponentCategory enum to protobuf ComponentCategory message.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/","title":"pagination","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination","title":"frequenz.client.common.pagination","text":"<p>Module to define the pagination used with the common client.</p>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info","title":"frequenz.client.common.pagination.Info  <code>dataclass</code>","text":"<p>Information about the pagination of a list request.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Info:\n    \"\"\"Information about the pagination of a list request.\"\"\"\n\n    total_items: int\n    \"\"\"The total number of items that match the request.\"\"\"\n\n    next_page_token: str | None = None\n    \"\"\"The token identifying the next page of results.\"\"\"\n\n    @classmethod\n    def from_proto(cls, pagination_info: PaginationInfo) -&gt; Self:\n        \"\"\"Convert a protobuf PBPaginationInfo to Info object.\n\n        Args:\n            pagination_info: Info to convert.\n        Returns:\n            Info object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            total_items=pagination_info.total_items,\n            next_page_token=pagination_info.next_page_token,\n        )\n\n    def to_proto(self) -&gt; PaginationInfo:\n        \"\"\"Convert a Info object to protobuf PBPaginationInfo.\n\n        Returns:\n            Protobuf message corresponding to the Info object.\n        \"\"\"\n        return PaginationInfo(\n            total_items=self.total_items,\n            next_page_token=self.next_page_token,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info.next_page_token","title":"next_page_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_page_token: str | None = None\n</code></pre> <p>The token identifying the next page of results.</p>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info.total_items","title":"total_items  <code>instance-attribute</code>","text":"<pre><code>total_items: int\n</code></pre> <p>The total number of items that match the request.</p>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(pagination_info: PaginationInfo) -&gt; Self\n</code></pre> <p>Convert a protobuf PBPaginationInfo to Info object.</p> PARAMETER  DESCRIPTION <code>pagination_info</code> <p>Info to convert.</p> <p> TYPE: <code>PaginationInfo</code> </p> <p>Returns:     Info object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>@classmethod\ndef from_proto(cls, pagination_info: PaginationInfo) -&gt; Self:\n    \"\"\"Convert a protobuf PBPaginationInfo to Info object.\n\n    Args:\n        pagination_info: Info to convert.\n    Returns:\n        Info object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        total_items=pagination_info.total_items,\n        next_page_token=pagination_info.next_page_token,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Info.to_proto","title":"to_proto","text":"<pre><code>to_proto() -&gt; PaginationInfo\n</code></pre> <p>Convert a Info object to protobuf PBPaginationInfo.</p> RETURNS DESCRIPTION <code>PaginationInfo</code> <p>Protobuf message corresponding to the Info object.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>def to_proto(self) -&gt; PaginationInfo:\n    \"\"\"Convert a Info object to protobuf PBPaginationInfo.\n\n    Returns:\n        Protobuf message corresponding to the Info object.\n    \"\"\"\n    return PaginationInfo(\n        total_items=self.total_items,\n        next_page_token=self.next_page_token,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params","title":"frequenz.client.common.pagination.Params  <code>dataclass</code>","text":"<p>Parameters for paginating list requests.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Params:\n    \"\"\"Parameters for paginating list requests.\"\"\"\n\n    page_size: int | None = None\n    \"\"\"The maximum number of results to be returned per request.\"\"\"\n\n    page_token: str | None = None\n    \"\"\"The token identifying a specific page of the list results.\"\"\"\n\n    @classmethod\n    def from_proto(cls, pagination_params: PaginationParams) -&gt; Self:\n        \"\"\"Convert a protobuf Params to PaginationParams object.\n\n        Args:\n            pagination_params: Params to convert.\n        Returns:\n            Params object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            page_size=pagination_params.page_size,\n            page_token=pagination_params.page_token,\n        )\n\n    def to_proto(self) -&gt; PaginationParams:\n        \"\"\"Convert a Params object to protobuf PaginationParams.\n\n        Returns:\n            Protobuf message corresponding to the Params object.\n        \"\"\"\n        return PaginationParams(\n            page_size=self.page_size,\n            page_token=self.page_token,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params.page_size","title":"page_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_size: int | None = None\n</code></pre> <p>The maximum number of results to be returned per request.</p>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params.page_token","title":"page_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_token: str | None = None\n</code></pre> <p>The token identifying a specific page of the list results.</p>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(pagination_params: PaginationParams) -&gt; Self\n</code></pre> <p>Convert a protobuf Params to PaginationParams object.</p> PARAMETER  DESCRIPTION <code>pagination_params</code> <p>Params to convert.</p> <p> TYPE: <code>PaginationParams</code> </p> <p>Returns:     Params object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>@classmethod\ndef from_proto(cls, pagination_params: PaginationParams) -&gt; Self:\n    \"\"\"Convert a protobuf Params to PaginationParams object.\n\n    Args:\n        pagination_params: Params to convert.\n    Returns:\n        Params object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        page_size=pagination_params.page_size,\n        page_token=pagination_params.page_token,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/common/pagination/#frequenz.client.common.pagination.Params.to_proto","title":"to_proto","text":"<pre><code>to_proto() -&gt; PaginationParams\n</code></pre> <p>Convert a Params object to protobuf PaginationParams.</p> RETURNS DESCRIPTION <code>PaginationParams</code> <p>Protobuf message corresponding to the Params object.</p> Source code in <code>frequenz/client/common/pagination/__init__.py</code> <pre><code>def to_proto(self) -&gt; PaginationParams:\n    \"\"\"Convert a Params object to protobuf PaginationParams.\n\n    Returns:\n        Protobuf message corresponding to the Params object.\n    \"\"\"\n    return PaginationParams(\n        page_size=self.page_size,\n        page_token=self.page_token,\n    )\n</code></pre>"}]}